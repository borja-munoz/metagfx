// ============================================================================
// include/metagfx/rhi/vulkan/VulkanDescriptorSet.h
// ============================================================================
#pragma once

#include "metagfx/core/Types.h"
#include "VulkanTypes.h"
#include <vector>

namespace metagfx {
namespace rhi {

// Forward declarations
class VulkanBuffer;

struct DescriptorBinding {
    uint32 binding;
    VkDescriptorType type;
    VkShaderStageFlags stageFlags;
    Ref<Buffer> buffer;  // For uniform/storage buffers
};

class VulkanDescriptorSet {
public:
    VulkanDescriptorSet(VulkanContext& context, const std::vector<DescriptorBinding>& bindings);
    ~VulkanDescriptorSet();

    void UpdateBuffer(uint32 binding, Ref<Buffer> buffer);
    
    VkDescriptorSetLayout GetLayout() const { return m_Layout; }
    VkDescriptorSet GetSet(uint32 frameIndex) const { return m_DescriptorSets[frameIndex]; }

private:
    void CreateLayout(const std::vector<DescriptorBinding>& bindings);
    void AllocateSets();
    void UpdateSets(const std::vector<DescriptorBinding>& bindings);

    VulkanContext& m_Context;
    VkDescriptorSetLayout m_Layout = VK_NULL_HANDLE;
    VkDescriptorPool m_Pool = VK_NULL_HANDLE;
    std::vector<VkDescriptorSet> m_DescriptorSets;
    std::vector<DescriptorBinding> m_Bindings;
    
    static constexpr uint32 MAX_FRAMES = 2;
};

} // namespace rhi
} // namespace metagfx

// ============================================================================
// src/rhi/vulkan/VulkanDescriptorSet.cpp
// ============================================================================
#include "metagfx/core/Logger.h"
#include "metagfx/rhi/vulkan/VulkanDescriptorSet.h"
#include "metagfx/rhi/vulkan/VulkanBuffer.h"

namespace metagfx {
namespace rhi {

VulkanDescriptorSet::VulkanDescriptorSet(VulkanContext& context, 
                                         const std::vector<DescriptorBinding>& bindings)
    : m_Context(context), m_Bindings(bindings) {
    
    CreateLayout(bindings);
    AllocateSets();
    UpdateSets(bindings);
}

VulkanDescriptorSet::~VulkanDescriptorSet() {
    if (m_Pool != VK_NULL_HANDLE) {
        vkDestroyDescriptorPool(m_Context.device, m_Pool, nullptr);
    }
    
    if (m_Layout != VK_NULL_HANDLE) {
        vkDestroyDescriptorSetLayout(m_Context.device, m_Layout, nullptr);
    }
}

void VulkanDescriptorSet::CreateLayout(const std::vector<DescriptorBinding>& bindings) {
    std::vector<VkDescriptorSetLayoutBinding> layoutBindings;
    
    for (const auto& binding : bindings) {
        VkDescriptorSetLayoutBinding layoutBinding{};
        layoutBinding.binding = binding.binding;
        layoutBinding.descriptorType = binding.type;
        layoutBinding.descriptorCount = 1;
        layoutBinding.stageFlags = binding.stageFlags;
        layoutBinding.pImmutableSamplers = nullptr;
        
        layoutBindings.push_back(layoutBinding);
    }
    
    VkDescriptorSetLayoutCreateInfo layoutInfo{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = static_cast<uint32>(layoutBindings.size());
    layoutInfo.pBindings = layoutBindings.data();
    
    VK_CHECK(vkCreateDescriptorSetLayout(m_Context.device, &layoutInfo, nullptr, &m_Layout));
}

void VulkanDescriptorSet::AllocateSets() {
    // Create descriptor pool
    std::vector<VkDescriptorPoolSize> poolSizes;
    
    for (const auto& binding : m_Bindings) {
        VkDescriptorPoolSize poolSize{};
        poolSize.type = binding.type;
        poolSize.descriptorCount = MAX_FRAMES;
        poolSizes.push_back(poolSize);
    }
    
    VkDescriptorPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    poolInfo.poolSizeCount = static_cast<uint32>(poolSizes.size());
    poolInfo.pPoolSizes = poolSizes.data();
    poolInfo.maxSets = MAX_FRAMES;
    
    VK_CHECK(vkCreateDescriptorPool(m_Context.device, &poolInfo, nullptr, &m_Pool));
    
    // Allocate descriptor sets
    std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES, m_Layout);
    
    VkDescriptorSetAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    allocInfo.descriptorPool = m_Pool;
    allocInfo.descriptorSetCount = MAX_FRAMES;
    allocInfo.pSetLayouts = layouts.data();
    
    m_DescriptorSets.resize(MAX_FRAMES);
    VK_CHECK(vkAllocateDescriptorSets(m_Context.device, &allocInfo, m_DescriptorSets.data()));
}

void VulkanDescriptorSet::UpdateSets(const std::vector<DescriptorBinding>& bindings) {
    for (uint32 i = 0; i < MAX_FRAMES; i++) {
        std::vector<VkWriteDescriptorSet> descriptorWrites;
        std::vector<VkDescriptorBufferInfo> bufferInfos;
        
        for (const auto& binding : bindings) {
            if (binding.buffer) {
                auto vkBuffer = std::static_pointer_cast<VulkanBuffer>(binding.buffer);
                
                VkDescriptorBufferInfo bufferInfo{};
                bufferInfo.buffer = vkBuffer->GetHandle();
                bufferInfo.offset = 0;
                bufferInfo.range = vkBuffer->GetSize();
                bufferInfos.push_back(bufferInfo);
                
                VkWriteDescriptorSet descriptorWrite{};
                descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
                descriptorWrite.dstSet = m_DescriptorSets[i];
                descriptorWrite.dstBinding = binding.binding;
                descriptorWrite.dstArrayElement = 0;
                descriptorWrite.descriptorType = binding.type;
                descriptorWrite.descriptorCount = 1;
                descriptorWrite.pBufferInfo = &bufferInfos.back();
                
                descriptorWrites.push_back(descriptorWrite);
            }
        }
        
        vkUpdateDescriptorSets(m_Context.device, 
                              static_cast<uint32>(descriptorWrites.size()), 
                              descriptorWrites.data(), 0, nullptr);
    }
}

void VulkanDescriptorSet::UpdateBuffer(uint32 binding, Ref<Buffer> buffer) {
    for (auto& b : m_Bindings) {
        if (b.binding == binding) {
            b.buffer = buffer;
            break;
        }
    }
    UpdateSets(m_Bindings);
}

} // namespace rhi
} // namespace metagfx