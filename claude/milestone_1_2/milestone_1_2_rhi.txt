// ============================================================================
// include/pbr/rhi/Types.h - Core RHI Types and Enums
// ============================================================================
#pragma once

#include "pbr/core/Types.h"
#include <string>
#include <vector>

namespace pbr {
namespace rhi {

// Forward declarations
class GraphicsDevice;
class SwapChain;
class CommandBuffer;
class Buffer;
class Texture;
class Shader;
class Pipeline;
class RenderPass;

// ============================================================================
// Enumerations
// ============================================================================

enum class GraphicsAPI {
    Vulkan,
    Direct3D12,
    Metal,
    WebGPU
};

enum class BufferUsage {
    Vertex      = 1 << 0,
    Index       = 1 << 1,
    Uniform     = 1 << 2,
    Storage     = 1 << 3,
    TransferSrc = 1 << 4,
    TransferDst = 1 << 5
};

inline BufferUsage operator|(BufferUsage a, BufferUsage b) {
    return static_cast<BufferUsage>(static_cast<int>(a) | static_cast<int>(b));
}

inline BufferUsage operator&(BufferUsage a, BufferUsage b) {
    return static_cast<BufferUsage>(static_cast<int>(a) & static_cast<int>(b));
}

enum class MemoryUsage {
    GPUOnly,        // Device local, not visible to CPU
    CPUToGPU,       // CPU writes, GPU reads (staging, dynamic)
    GPUToCPU,       // GPU writes, CPU reads (readback)
    CPUOnly         // CPU only (for staging)
};

enum class ShaderStage {
    Vertex,
    Fragment,
    Compute,
    Geometry,
    TessellationControl,
    TessellationEvaluation
};

enum class PrimitiveTopology {
    TriangleList,
    TriangleStrip,
    LineList,
    LineStrip,
    PointList
};

enum class PolygonMode {
    Fill,
    Line,
    Point
};

enum class CullMode {
    None,
    Front,
    Back,
    FrontAndBack
};

enum class FrontFace {
    Clockwise,
    CounterClockwise
};

enum class CompareOp {
    Never,
    Less,
    Equal,
    LessOrEqual,
    Greater,
    NotEqual,
    GreaterOrEqual,
    Always
};

enum class Format {
    Undefined,
    
    // 8-bit formats
    R8_UNORM,
    R8_SNORM,
    R8_UINT,
    R8_SINT,
    
    // 16-bit formats
    R16_UNORM,
    R16_SNORM,
    R16_UINT,
    R16_SINT,
    R16_SFLOAT,
    
    // 32-bit formats
    R32_UINT,
    R32_SINT,
    R32_SFLOAT,
    
    // Two component 8-bit
    R8G8_UNORM,
    R8G8_SNORM,
    R8G8_UINT,
    R8G8_SINT,
    
    // Two component 16-bit
    R16G16_UNORM,
    R16G16_SNORM,
    R16G16_UINT,
    R16G16_SINT,
    R16G16_SFLOAT,
    
    // Two component 32-bit
    R32G32_UINT,
    R32G32_SINT,
    R32G32_SFLOAT,
    
    // Three component 32-bit
    R32G32B32_UINT,
    R32G32B32_SINT,
    R32G32B32_SFLOAT,
    
    // Four component 8-bit
    R8G8B8A8_UNORM,
    R8G8B8A8_SNORM,
    R8G8B8A8_UINT,
    R8G8B8A8_SINT,
    R8G8B8A8_SRGB,
    
    B8G8R8A8_UNORM,
    B8G8R8A8_SRGB,
    
    // Four component 16-bit
    R16G16B16A16_UNORM,
    R16G16B16A16_SNORM,
    R16G16B16A16_UINT,
    R16G16B16A16_SINT,
    R16G16B16A16_SFLOAT,
    
    // Four component 32-bit
    R32G32B32A32_UINT,
    R32G32B32A32_SINT,
    R32G32B32A32_SFLOAT,
    
    // Depth/Stencil formats
    D16_UNORM,
    D32_SFLOAT,
    D24_UNORM_S8_UINT,
    D32_SFLOAT_S8_UINT
};

enum class TextureUsage {
    Sampled         = 1 << 0,
    Storage         = 1 << 1,
    ColorAttachment = 1 << 2,
    DepthStencilAttachment = 1 << 3,
    TransferSrc     = 1 << 4,
    TransferDst     = 1 << 5
};

inline TextureUsage operator|(TextureUsage a, TextureUsage b) {
    return static_cast<TextureUsage>(static_cast<int>(a) | static_cast<int>(b));
}

enum class Filter {
    Nearest,
    Linear
};

enum class SamplerAddressMode {
    Repeat,
    MirroredRepeat,
    ClampToEdge,
    ClampToBorder
};

// ============================================================================
// Structures
// ============================================================================

struct DeviceInfo {
    std::string deviceName;
    GraphicsAPI api;
    uint32 apiVersion;
    uint64 deviceMemory;
};

struct BufferDesc {
    uint64 size = 0;
    BufferUsage usage;
    MemoryUsage memoryUsage = MemoryUsage::GPUOnly;
    const char* debugName = nullptr;
};

struct TextureDesc {
    uint32 width = 1;
    uint32 height = 1;
    uint32 depth = 1;
    uint32 mipLevels = 1;
    uint32 arrayLayers = 1;
    Format format = Format::R8G8B8A8_UNORM;
    TextureUsage usage;
    const char* debugName = nullptr;
};

struct SamplerDesc {
    Filter minFilter = Filter::Linear;
    Filter magFilter = Filter::Linear;
    Filter mipmapMode = Filter::Linear;
    SamplerAddressMode addressModeU = SamplerAddressMode::Repeat;
    SamplerAddressMode addressModeV = SamplerAddressMode::Repeat;
    SamplerAddressMode addressModeW = SamplerAddressMode::Repeat;
    float mipLodBias = 0.0f;
    float minLod = 0.0f;
    float maxLod = 1000.0f;
    bool anisotropyEnable = false;
    float maxAnisotropy = 1.0f;
};

struct ShaderDesc {
    ShaderStage stage;
    std::vector<uint8> code;  // Shader bytecode (SPIRV, DXIL, etc.)
    std::string entryPoint = "main";
    const char* debugName = nullptr;
};

struct VertexAttribute {
    uint32 location;
    Format format;
    uint32 offset;
};

struct VertexInputLayout {
    std::vector<VertexAttribute> attributes;
    uint32 stride;
};

struct RasterizationState {
    PolygonMode polygonMode = PolygonMode::Fill;
    CullMode cullMode = CullMode::Back;
    FrontFace frontFace = FrontFace::CounterClockwise;
    bool depthClampEnable = false;
    bool depthBiasEnable = false;
    float depthBiasConstantFactor = 0.0f;
    float depthBiasSlopeFactor = 0.0f;
    float lineWidth = 1.0f;
};

struct DepthStencilState {
    bool depthTestEnable = true;
    bool depthWriteEnable = true;
    CompareOp depthCompareOp = CompareOp::Less;
    bool stencilTestEnable = false;
};

struct ColorAttachmentState {
    bool blendEnable = false;
    // Blend operations will be added when needed
};

struct PipelineDesc {
    Ref<Shader> vertexShader;
    Ref<Shader> fragmentShader;
    VertexInputLayout vertexInput;
    PrimitiveTopology topology = PrimitiveTopology::TriangleList;
    RasterizationState rasterization;
    DepthStencilState depthStencil;
    std::vector<ColorAttachmentState> colorAttachments;
    const char* debugName = nullptr;
};

struct Viewport {
    float x = 0.0f;
    float y = 0.0f;
    float width = 0.0f;
    float height = 0.0f;
    float minDepth = 0.0f;
    float maxDepth = 1.0f;
};

struct Rect2D {
    int32 x = 0;
    int32 y = 0;
    uint32 width = 0;
    uint32 height = 0;
};

struct ClearValue {
    union {
        float color[4];
        struct {
            float depth;
            uint32 stencil;
        } depthStencil;
    };
};

// ============================================================================
// include/pbr/rhi/Buffer.h
// ============================================================================
class Buffer {
public:
    virtual ~Buffer() = default;
    
    virtual void* Map() = 0;
    virtual void Unmap() = 0;
    virtual void CopyData(const void* data, uint64 size, uint64 offset = 0) = 0;
    
    virtual uint64 GetSize() const = 0;
    virtual BufferUsage GetUsage() const = 0;
    
protected:
    Buffer() = default;
};

// ============================================================================
// include/pbr/rhi/Texture.h
// ============================================================================
class Texture {
public:
    virtual ~Texture() = default;
    
    virtual uint32 GetWidth() const = 0;
    virtual uint32 GetHeight() const = 0;
    virtual Format GetFormat() const = 0;
    
protected:
    Texture() = default;
};

// ============================================================================
// include/pbr/rhi/Shader.h
// ============================================================================
class Shader {
public:
    virtual ~Shader() = default;
    
    virtual ShaderStage GetStage() const = 0;
    
protected:
    Shader() = default;
};

// ============================================================================
// include/pbr/rhi/Pipeline.h
// ============================================================================
class Pipeline {
public:
    virtual ~Pipeline() = default;
    
protected:
    Pipeline() = default;
};

// ============================================================================
// include/pbr/rhi/CommandBuffer.h
// ============================================================================
class CommandBuffer {
public:
    virtual ~CommandBuffer() = default;
    
    // Command recording
    virtual void Begin() = 0;
    virtual void End() = 0;
    
    // Render pass commands
    virtual void BeginRendering(const std::vector<Ref<Texture>>& colorAttachments,
                                Ref<Texture> depthAttachment,
                                const std::vector<ClearValue>& clearValues) = 0;
    virtual void EndRendering() = 0;
    
    // Pipeline binding
    virtual void BindPipeline(Ref<Pipeline> pipeline) = 0;
    
    // Viewport and scissor
    virtual void SetViewport(const Viewport& viewport) = 0;
    virtual void SetScissor(const Rect2D& scissor) = 0;
    
    // Vertex and index buffers
    virtual void BindVertexBuffer(Ref<Buffer> buffer, uint64 offset = 0) = 0;
    virtual void BindIndexBuffer(Ref<Buffer> buffer, uint64 offset = 0) = 0;
    
    // Draw commands
    virtual void Draw(uint32 vertexCount, uint32 instanceCount = 1,
                     uint32 firstVertex = 0, uint32 firstInstance = 0) = 0;
    virtual void DrawIndexed(uint32 indexCount, uint32 instanceCount = 1,
                            uint32 firstIndex = 0, int32 vertexOffset = 0,
                            uint32 firstInstance = 0) = 0;
    
    // Copy commands
    virtual void CopyBuffer(Ref<Buffer> src, Ref<Buffer> dst,
                           uint64 size, uint64 srcOffset = 0, uint64 dstOffset = 0) = 0;
    
protected:
    CommandBuffer() = default;
};

// ============================================================================
// include/pbr/rhi/SwapChain.h
// ============================================================================
class SwapChain {
public:
    virtual ~SwapChain() = default;
    
    virtual void Present() = 0;
    virtual void Resize(uint32 width, uint32 height) = 0;
    
    virtual Ref<Texture> GetCurrentBackBuffer() = 0;
    virtual uint32 GetWidth() const = 0;
    virtual uint32 GetHeight() const = 0;
    virtual Format GetFormat() const = 0;
    
protected:
    SwapChain() = default;
};

// ============================================================================
// include/pbr/rhi/GraphicsDevice.h - Updated
// ============================================================================
class GraphicsDevice {
public:
    virtual ~GraphicsDevice() = default;
    
    // Device information
    virtual const DeviceInfo& GetDeviceInfo() const = 0;
    
    // Resource creation
    virtual Ref<Buffer> CreateBuffer(const BufferDesc& desc) = 0;
    virtual Ref<Texture> CreateTexture(const TextureDesc& desc) = 0;
    virtual Ref<Shader> CreateShader(const ShaderDesc& desc) = 0;
    virtual Ref<Pipeline> CreateGraphicsPipeline(const PipelineDesc& desc) = 0;
    
    // Command buffer management
    virtual Ref<CommandBuffer> CreateCommandBuffer() = 0;
    virtual void SubmitCommandBuffer(Ref<CommandBuffer> commandBuffer) = 0;
    
    // Synchronization
    virtual void WaitIdle() = 0;
    
    // Swap chain
    virtual Ref<SwapChain> GetSwapChain() = 0;
    
protected:
    GraphicsDevice() = default;
};

// ============================================================================
// Factory function for creating devices
// ============================================================================
Ref<GraphicsDevice> CreateGraphicsDevice(GraphicsAPI api, void* nativeWindowHandle);

} // namespace rhi
} // namespace pbr

// ============================================================================
// USAGE EXAMPLE - For reference, not part of actual code
// ============================================================================
/*

// Example of how the RHI will be used in the renderer:

#include "pbr/rhi/GraphicsDevice.h"

using namespace pbr;
using namespace pbr::rhi;

void ExampleUsage(void* windowHandle) {
    // 1. Create graphics device
    auto device = CreateGraphicsDevice(GraphicsAPI::Vulkan, windowHandle);
    
    // 2. Create vertex buffer
    BufferDesc vertexBufferDesc;
    vertexBufferDesc.size = sizeof(float) * 9; // 3 vertices * 3 floats
    vertexBufferDesc.usage = BufferUsage::Vertex;
    vertexBufferDesc.memoryUsage = MemoryUsage::CPUToGPU;
    auto vertexBuffer = device->CreateBuffer(vertexBufferDesc);
    
    // 3. Upload vertex data
    float vertices[] = {
        0.0f,  0.5f, 0.0f,
       -0.5f, -0.5f, 0.0f,
        0.5f, -0.5f, 0.0f
    };
    vertexBuffer->CopyData(vertices, sizeof(vertices));
    
    // 4. Create shaders
    ShaderDesc vertShaderDesc;
    vertShaderDesc.stage = ShaderStage::Vertex;
    vertShaderDesc.code = LoadShaderCode("triangle.vert.spv");
    auto vertShader = device->CreateShader(vertShaderDesc);
    
    ShaderDesc fragShaderDesc;
    fragShaderDesc.stage = ShaderStage::Fragment;
    fragShaderDesc.code = LoadShaderCode("triangle.frag.spv");
    auto fragShader = device->CreateShader(fragShaderDesc);
    
    // 5. Create graphics pipeline
    PipelineDesc pipelineDesc;
    pipelineDesc.vertexShader = vertShader;
    pipelineDesc.fragmentShader = fragShader;
    
    // Vertex input layout
    pipelineDesc.vertexInput.stride = sizeof(float) * 3;
    pipelineDesc.vertexInput.attributes = {
        { 0, Format::R32G32B32_SFLOAT, 0 }  // position
    };
    
    pipelineDesc.topology = PrimitiveTopology::TriangleList;
    pipelineDesc.rasterization.cullMode = CullMode::None;
    
    auto pipeline = device->CreateGraphicsPipeline(pipelineDesc);
    
    // 6. Render loop
    while (running) {
        auto swapChain = device->GetSwapChain();
        auto backBuffer = swapChain->GetCurrentBackBuffer();
        
        // Create command buffer
        auto cmd = device->CreateCommandBuffer();
        cmd->Begin();
        
        // Begin rendering
        ClearValue clearValue;
        clearValue.color[0] = 0.1f;
        clearValue.color[1] = 0.1f;
        clearValue.color[2] = 0.1f;
        clearValue.color[3] = 1.0f;
        
        cmd->BeginRendering({ backBuffer }, nullptr, { clearValue });
        
        // Set viewport and scissor
        Viewport viewport;
        viewport.width = swapChain->GetWidth();
        viewport.height = swapChain->GetHeight();
        cmd->SetViewport(viewport);
        
        Rect2D scissor;
        scissor.width = swapChain->GetWidth();
        scissor.height = swapChain->GetHeight();
        cmd->SetScissor(scissor);
        
        // Bind pipeline and draw
        cmd->BindPipeline(pipeline);
        cmd->BindVertexBuffer(vertexBuffer);
        cmd->Draw(3);
        
        cmd->EndRendering();
        cmd->End();
        
        // Submit and present
        device->SubmitCommandBuffer(cmd);
        swapChain->Present();
    }
    
    device->WaitIdle();
}

*/

// ============================================================================
// src/rhi/GraphicsDevice.cpp - Updated with factory function
// ============================================================================
#include "pbr/rhi/GraphicsDevice.h"
#include "pbr/core/Logger.h"

#ifdef PBR_USE_VULKAN
// Will be implemented in Milestone 1.3
// #include "pbr/rhi/vulkan/VulkanDevice.h"
#endif

namespace pbr {
namespace rhi {

Ref<GraphicsDevice> CreateGraphicsDevice(GraphicsAPI api, void* nativeWindowHandle) {
    (void)nativeWindowHandle; // Suppress unused warning for now
    
    switch (api) {
#ifdef PBR_USE_VULKAN
        case GraphicsAPI::Vulkan:
            PBR_INFO("Creating Vulkan graphics device...");
            // Will be implemented in Milestone 1.3
            // return CreateRef<VulkanDevice>(nativeWindowHandle);
            PBR_ERROR("Vulkan device creation not yet implemented (Milestone 1.3)");
            return nullptr;
#endif
            
#ifdef PBR_USE_D3D12
        case GraphicsAPI::Direct3D12:
            PBR_ERROR("Direct3D 12 not yet implemented (Milestone 4.1)");
            return nullptr;
#endif
            
#ifdef PBR_USE_METAL
        case GraphicsAPI::Metal:
            PBR_ERROR("Metal not yet implemented (Milestone 4.2)");
            return nullptr;
#endif
            
#ifdef PBR_USE_WEBGPU
        case GraphicsAPI::WebGPU:
            PBR_ERROR("WebGPU not yet implemented (Milestone 4.3)");
            return nullptr;
#endif
            
        default:
            PBR_ERROR("Unknown or unsupported graphics API");
            return nullptr;
    }
}

} // namespace rhi
} // namespace pbr