// ============================================================================
// src/rhi/vulkan/VulkanTypes.cpp
// ============================================================================
#include "pbr/rhi/vulkan/VulkanTypes.h"

namespace pbr {
namespace rhi {

VkFormat ToVulkanFormat(Format format) {
    switch (format) {
        case Format::R8_UNORM: return VK_FORMAT_R8_UNORM;
        case Format::R8G8B8A8_UNORM: return VK_FORMAT_R8G8B8A8_UNORM;
        case Format::R8G8B8A8_SRGB: return VK_FORMAT_R8G8B8A8_SRGB;
        case Format::B8G8R8A8_UNORM: return VK_FORMAT_B8G8R8A8_UNORM;
        case Format::B8G8R8A8_SRGB: return VK_FORMAT_B8G8R8A8_SRGB;
        case Format::R32_SFLOAT: return VK_FORMAT_R32_SFLOAT;
        case Format::R32G32_SFLOAT: return VK_FORMAT_R32G32_SFLOAT;
        case Format::R32G32B32_SFLOAT: return VK_FORMAT_R32G32B32_SFLOAT;
        case Format::R32G32B32A32_SFLOAT: return VK_FORMAT_R32G32B32A32_SFLOAT;
        case Format::D32_SFLOAT: return VK_FORMAT_D32_SFLOAT;
        case Format::D24_UNORM_S8_UINT: return VK_FORMAT_D24_UNORM_S8_UINT;
        default: return VK_FORMAT_UNDEFINED;
    }
}

Format FromVulkanFormat(VkFormat format) {
    switch (format) {
        case VK_FORMAT_R8_UNORM: return Format::R8_UNORM;
        case VK_FORMAT_R8G8B8A8_UNORM: return Format::R8G8B8A8_UNORM;
        case VK_FORMAT_R8G8B8A8_SRGB: return Format::R8G8B8A8_SRGB;
        case VK_FORMAT_B8G8R8A8_UNORM: return Format::B8G8R8A8_UNORM;
        case VK_FORMAT_B8G8R8A8_SRGB: return Format::B8G8R8A8_SRGB;
        case VK_FORMAT_R32_SFLOAT: return Format::R32_SFLOAT;
        case VK_FORMAT_R32G32_SFLOAT: return Format::R32G32_SFLOAT;
        case VK_FORMAT_R32G32B32_SFLOAT: return Format::R32G32B32_SFLOAT;
        case VK_FORMAT_R32G32B32A32_SFLOAT: return Format::R32G32B32A32_SFLOAT;
        case VK_FORMAT_D32_SFLOAT: return Format::D32_SFLOAT;
        case VK_FORMAT_D24_UNORM_S8_UINT: return Format::D24_UNORM_S8_UINT;
        default: return Format::Undefined;
    }
}

VkBufferUsageFlags ToVulkanBufferUsage(BufferUsage usage) {
    VkBufferUsageFlags flags = 0;
    if ((usage & BufferUsage::Vertex) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    if ((usage & BufferUsage::Index) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    if ((usage & BufferUsage::Uniform) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    if ((usage & BufferUsage::Storage) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
    if ((usage & BufferUsage::TransferSrc) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    if ((usage & BufferUsage::TransferDst) != BufferUsage{})
        flags |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    return flags;
}

VkMemoryPropertyFlags ToVulkanMemoryUsage(MemoryUsage usage) {
    switch (usage) {
        case MemoryUsage::GPUOnly:
            return VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        case MemoryUsage::CPUToGPU:
            return VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        case MemoryUsage::GPUToCPU:
            return VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
        case MemoryUsage::CPUOnly:
            return VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        default:
            return VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
    }
}

VkShaderStageFlagBits ToVulkanShaderStage(ShaderStage stage) {
    switch (stage) {
        case ShaderStage::Vertex: return VK_SHADER_STAGE_VERTEX_BIT;
        case ShaderStage::Fragment: return VK_SHADER_STAGE_FRAGMENT_BIT;
        case ShaderStage::Compute: return VK_SHADER_STAGE_COMPUTE_BIT;
        case ShaderStage::Geometry: return VK_SHADER_STAGE_GEOMETRY_BIT;
        case ShaderStage::TessellationControl: return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
        case ShaderStage::TessellationEvaluation: return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
        default: return VK_SHADER_STAGE_VERTEX_BIT;
    }
}

VkPrimitiveTopology ToVulkanTopology(PrimitiveTopology topology) {
    switch (topology) {
        case PrimitiveTopology::TriangleList: return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        case PrimitiveTopology::TriangleStrip: return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
        case PrimitiveTopology::LineList: return VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
        case PrimitiveTopology::LineStrip: return VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
        case PrimitiveTopology::PointList: return VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
        default: return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    }
}

VkPolygonMode ToVulkanPolygonMode(PolygonMode mode) {
    switch (mode) {
        case PolygonMode::Fill: return VK_POLYGON_MODE_FILL;
        case PolygonMode::Line: return VK_POLYGON_MODE_LINE;
        case PolygonMode::Point: return VK_POLYGON_MODE_POINT;
        default: return VK_POLYGON_MODE_FILL;
    }
}

VkCullModeFlags ToVulkanCullMode(CullMode mode) {
    switch (mode) {
        case CullMode::None: return VK_CULL_MODE_NONE;
        case CullMode::Front: return VK_CULL_MODE_FRONT_BIT;
        case CullMode::Back: return VK_CULL_MODE_BACK_BIT;
        case CullMode::FrontAndBack: return VK_CULL_MODE_FRONT_AND_BACK;
        default: return VK_CULL_MODE_BACK_BIT;
    }
}

VkFrontFace ToVulkanFrontFace(FrontFace face) {
    switch (face) {
        case FrontFace::Clockwise: return VK_FRONT_FACE_CLOCKWISE;
        case FrontFace::CounterClockwise: return VK_FRONT_FACE_COUNTER_CLOCKWISE;
        default: return VK_FRONT_FACE_COUNTER_CLOCKWISE;
    }
}

VkCompareOp ToVulkanCompareOp(CompareOp op) {
    switch (op) {
        case CompareOp::Never: return VK_COMPARE_OP_NEVER;
        case CompareOp::Less: return VK_COMPARE_OP_LESS;
        case CompareOp::Equal: return VK_COMPARE_OP_EQUAL;
        case CompareOp::LessOrEqual: return VK_COMPARE_OP_LESS_OR_EQUAL;
        case CompareOp::Greater: return VK_COMPARE_OP_GREATER;
        case CompareOp::NotEqual: return VK_COMPARE_OP_NOT_EQUAL;
        case CompareOp::GreaterOrEqual: return VK_COMPARE_OP_GREATER_OR_EQUAL;
        case CompareOp::Always: return VK_COMPARE_OP_ALWAYS;
        default: return VK_COMPARE_OP_LESS;
    }
}

} // namespace rhi
} // namespace pbr

// ============================================================================
// src/rhi/vulkan/VulkanDevice.cpp
// ============================================================================
#include "pbr/core/Logger.h"
#include "pbr/rhi/vulkan/VulkanDevice.h"
#include "pbr/rhi/vulkan/VulkanSwapChain.h"
#include "pbr/rhi/vulkan/VulkanBuffer.h"
#include "pbr/rhi/vulkan/VulkanTexture.h"
#include "pbr/rhi/vulkan/VulkanShader.h"
#include "pbr/rhi/vulkan/VulkanPipeline.h"
#include "pbr/rhi/vulkan/VulkanCommandBuffer.h"

namespace pbr {
namespace rhi {

VulkanDevice::VulkanDevice(SDL_Window* window) : m_Window(window) {
    PBR_INFO << "Initializing Vulkan device...";
    
    CreateInstance(window);
    PickPhysicalDevice();
    CreateLogicalDevice();
    CreateCommandPool();
    
    // Create swap chain
    m_SwapChain = CreateRef<VulkanSwapChain>(m_Context, window);
    
    // Fill device info
    m_DeviceInfo.deviceName = std::string(m_Context.deviceProperties.deviceName);
    m_DeviceInfo.api = GraphicsAPI::Vulkan;
    m_DeviceInfo.apiVersion = m_Context.deviceProperties.apiVersion;
    
    PBR_INFO << "Vulkan device initialized: " << m_DeviceInfo.deviceName;
}

VulkanDevice::~VulkanDevice() {
    WaitIdle();
    
    m_SwapChain.reset();
    
    if (m_CommandPool != VK_NULL_HANDLE) {
        vkDestroyCommandPool(m_Context.device, m_CommandPool, nullptr);
    }
    
    if (m_Context.device != VK_NULL_HANDLE) {
        vkDestroyDevice(m_Context.device, nullptr);
    }
    
    if (m_Context.surface != VK_NULL_HANDLE) {
        vkDestroySurfaceKHR(m_Context.instance, m_Context.surface, nullptr);
    }
    
    if (m_Context.instance != VK_NULL_HANDLE) {
        vkDestroyInstance(m_Context.instance, nullptr);
    }
    
    PBR_INFO << "Vulkan device destroyed";
}

void VulkanDevice::CreateInstance(SDL_Window* window) {
    // Get required extensions from SDL
    uint32_t sdlExtensionCount = 0;
    const char* const* sdlExtensions = SDL_Vulkan_GetInstanceExtensions(&sdlExtensionCount);
    
    std::vector<const char*> extensions(sdlExtensions, sdlExtensions + sdlExtensionCount);
    
    VkApplicationInfo appInfo{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = "PBR Renderer";
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = "PBR Engine";
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_2;
    
    VkInstanceCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    createInfo.pApplicationInfo = &appInfo;
    createInfo.enabledExtensionCount = static_cast<uint32>(extensions.size());
    createInfo.ppEnabledExtensionNames = extensions.data();
    createInfo.enabledLayerCount = 0;
    
    // Enable portability enumeration for macOS
    #ifdef __APPLE__
    createInfo.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
    extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
    extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);
    createInfo.enabledExtensionCount = static_cast<uint32>(extensions.size());
    createInfo.ppEnabledExtensionNames = extensions.data();
    #endif
    
    VK_CHECK(vkCreateInstance(&createInfo, nullptr, &m_Context.instance));
    
    // Create surface
    if (!SDL_Vulkan_CreateSurface(window, m_Context.instance, nullptr, &m_Context.surface)) {
        PBR_ERROR << "Failed to create Vulkan surface: " << SDL_GetError();
    }
}

void VulkanDevice::PickPhysicalDevice() {
    uint32 deviceCount = 0;
    vkEnumeratePhysicalDevices(m_Context.instance, &deviceCount, nullptr);
    
    if (deviceCount == 0) {
        PBR_ERROR << "Failed to find GPUs with Vulkan support";
        return;
    }
    
    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(m_Context.instance, &deviceCount, devices.data());
    
    // Just pick the first device for now
    m_Context.physicalDevice = devices[0];
    
    vkGetPhysicalDeviceProperties(m_Context.physicalDevice, &m_Context.deviceProperties);
    vkGetPhysicalDeviceFeatures(m_Context.physicalDevice, &m_Context.deviceFeatures);
    vkGetPhysicalDeviceMemoryProperties(m_Context.physicalDevice, &m_Context.memoryProperties);
    
    PBR_INFO << "Selected GPU: " << m_Context.deviceProperties.deviceName;
}

void VulkanDevice::CreateLogicalDevice() {
    // Find queue families
    uint32 queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(m_Context.physicalDevice, &queueFamilyCount, nullptr);
    
    std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(m_Context.physicalDevice, &queueFamilyCount, queueFamilies.data());
    
    // Find graphics and present queue families
    for (uint32 i = 0; i < queueFamilyCount; i++) {
        if (queueFamilies[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            m_Context.graphicsQueueFamily = i;
        }
        
        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(m_Context.physicalDevice, i, m_Context.surface, &presentSupport);
        if (presentSupport) {
            m_Context.presentQueueFamily = i;
        }
    }
    
    // Create queue create infos
    std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
    float queuePriority = 1.0f;
    
    VkDeviceQueueCreateInfo queueCreateInfo{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = m_Context.graphicsQueueFamily;
    queueCreateInfo.queueCount = 1;
    queueCreateInfo.pQueuePriorities = &queuePriority;
    queueCreateInfos.push_back(queueCreateInfo);
    
    // Device features
    VkPhysicalDeviceFeatures deviceFeatures{};
    deviceFeatures.fillModeNonSolid = VK_TRUE; // For wireframe mode
    
    // Device extensions
    std::vector<const char*> deviceExtensions = {
        VK_KHR_SWAPCHAIN_EXTENSION_NAME
    };
    
    #ifdef __APPLE__
    deviceExtensions.push_back("VK_KHR_portability_subset");
    #endif
    
    VkDeviceCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    createInfo.queueCreateInfoCount = static_cast<uint32>(queueCreateInfos.size());
    createInfo.pQueueCreateInfos = queueCreateInfos.data();
    createInfo.pEnabledFeatures = &deviceFeatures;
    createInfo.enabledExtensionCount = static_cast<uint32>(deviceExtensions.size());
    createInfo.ppEnabledExtensionNames = deviceExtensions.data();
    
    VK_CHECK(vkCreateDevice(m_Context.physicalDevice, &createInfo, nullptr, &m_Context.device));
    
    vkGetDeviceQueue(m_Context.device, m_Context.graphicsQueueFamily, 0, &m_Context.graphicsQueue);
    vkGetDeviceQueue(m_Context.device, m_Context.presentQueueFamily, 0, &m_Context.presentQueue);
}

void VulkanDevice::CreateCommandPool() {
    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    poolInfo.queueFamilyIndex = m_Context.graphicsQueueFamily;
    
    VK_CHECK(vkCreateCommandPool(m_Context.device, &poolInfo, nullptr, &m_CommandPool));
}

Ref<Buffer> VulkanDevice::CreateBuffer(const BufferDesc& desc) {
    return CreateRef<VulkanBuffer>(m_Context, desc);
}

Ref<Texture> VulkanDevice::CreateTexture(const TextureDesc& desc) {
    return CreateRef<VulkanTexture>(m_Context, desc);
}

Ref<Shader> VulkanDevice::CreateShader(const ShaderDesc& desc) {
    return CreateRef<VulkanShader>(m_Context, desc);
}

Ref<Pipeline> VulkanDevice::CreateGraphicsPipeline(const PipelineDesc& desc) {
    // For now, create a simple render pass for the swap chain format
    auto swapChain = std::static_pointer_cast<VulkanSwapChain>(m_SwapChain);
    
    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = ToVulkanFormat(swapChain->GetFormat());
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    
    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    
    VkSubpassDescription subpass{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    
    VkRenderPassCreateInfo renderPassInfo{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = 1;
    renderPassInfo.pAttachments = &colorAttachment;
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    
    VkRenderPass renderPass;
    VK_CHECK(vkCreateRenderPass(m_Context.device, &renderPassInfo, nullptr, &renderPass));
    
    return CreateRef<VulkanPipeline>(m_Context, desc, renderPass);
}

Ref<CommandBuffer> VulkanDevice::CreateCommandBuffer() {
    return CreateRef<VulkanCommandBuffer>(m_Context, m_CommandPool);
}

void VulkanDevice::SubmitCommandBuffer(Ref<CommandBuffer> commandBuffer) {
    auto vkCmd = std::static_pointer_cast<VulkanCommandBuffer>(commandBuffer);
    auto swapChain = std::static_pointer_cast<VulkanSwapChain>(m_SwapChain);
    
    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    
    VkSemaphore waitSemaphores[] = { swapChain->GetImageAvailableSemaphore() };
    VkPipelineStageFlags waitStages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;
    
    VkCommandBuffer cmdBuffer = vkCmd->GetHandle();
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmdBuffer;
    
    VkSemaphore signalSemaphores[] = { swapChain->GetRenderFinishedSemaphore() };
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;
    
    vkResetFences(m_Context.device, 1, &swapChain->GetInFlightFence());
    VK_CHECK(vkQueueSubmit(m_Context.graphicsQueue, 1, &submitInfo, swapChain->GetInFlightFence()));
}

void VulkanDevice::WaitIdle() {
    if (m_Context.device != VK_NULL_HANDLE) {
        vkDeviceWaitIdle(m_Context.device);
    }
}

uint32 VulkanDevice::FindMemoryType(uint32 typeFilter, VkMemoryPropertyFlags properties) {
    for (uint32 i = 0; i < m_Context.memoryProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) && 
            (m_Context.memoryProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }
    
    PBR_ERROR << "Failed to find suitable memory type";
    return 0;
}

} // namespace rhi
} // namespace pbr