// ============================================================================
// src/rhi/vulkan/VulkanShader.cpp
// ============================================================================
#include "pbr/core/Logger.h"
#include "pbr/rhi/vulkan/VulkanShader.h"

namespace pbr {
namespace rhi {

VulkanShader::VulkanShader(VulkanContext& context, const ShaderDesc& desc)
    : m_Context(context), m_Stage(desc.stage), m_EntryPoint(desc.entryPoint) {
    
    VkShaderModuleCreateInfo createInfo{};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = desc.code.size();
    createInfo.pCode = reinterpret_cast<const uint32*>(desc.code.data());
    
    VK_CHECK(vkCreateShaderModule(m_Context.device, &createInfo, nullptr, &m_Module));
    
    PBR_DEBUG << "Vulkan shader created";
}

VulkanShader::~VulkanShader() {
    if (m_Module != VK_NULL_HANDLE) {
        vkDestroyShaderModule(m_Context.device, m_Module, nullptr);
    }
}

} // namespace rhi
} // namespace pbr

// ============================================================================
// src/rhi/vulkan/VulkanPipeline.cpp
// ============================================================================
#include "pbr/core/Logger.h"
#include "pbr/rhi/vulkan/VulkanPipeline.h"
#include "pbr/rhi/vulkan/VulkanShader.h"

namespace pbr {
namespace rhi {

VulkanPipeline::VulkanPipeline(VulkanContext& context, const PipelineDesc& desc, VkRenderPass renderPass)
    : m_Context(context) {
    
    // Shader stages
    auto vertShader = std::static_pointer_cast<VulkanShader>(desc.vertexShader);
    auto fragShader = std::static_pointer_cast<VulkanShader>(desc.fragmentShader);
    
    VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShader->GetModule();
    vertShaderStageInfo.pName = vertShader->GetEntryPoint().c_str();
    
    VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShader->GetModule();
    fragShaderStageInfo.pName = fragShader->GetEntryPoint().c_str();
    
    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };
    
    // Vertex input
    std::vector<VkVertexInputAttributeDescription> attributeDescs;
    for (const auto& attr : desc.vertexInput.attributes) {
        VkVertexInputAttributeDescription attrDesc{};
        attrDesc.location = attr.location;
        attrDesc.binding = 0;
        attrDesc.format = ToVulkanFormat(attr.format);
        attrDesc.offset = attr.offset;
        attributeDescs.push_back(attrDesc);
    }
    
    VkVertexInputBindingDescription bindingDesc{};
    bindingDesc.binding = 0;
    bindingDesc.stride = desc.vertexInput.stride;
    bindingDesc.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    
    VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.pVertexBindingDescriptions = &bindingDesc;
    vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32>(attributeDescs.size());
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescs.data();
    
    // Input assembly
    VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = ToVulkanTopology(desc.topology);
    inputAssembly.primitiveRestartEnable = VK_FALSE;
    
    // Viewport and scissor (dynamic)
    VkPipelineViewportStateCreateInfo viewportState{};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.scissorCount = 1;
    
    // Rasterization
    VkPipelineRasterizationStateCreateInfo rasterizer{};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = desc.rasterization.depthClampEnable ? VK_TRUE : VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = ToVulkanPolygonMode(desc.rasterization.polygonMode);
    rasterizer.lineWidth = desc.rasterization.lineWidth;
    rasterizer.cullMode = ToVulkanCullMode(desc.rasterization.cullMode);
    rasterizer.frontFace = ToVulkanFrontFace(desc.rasterization.frontFace);
    rasterizer.depthBiasEnable = desc.rasterization.depthBiasEnable ? VK_TRUE : VK_FALSE;
    
    // Multisampling
    VkPipelineMultisampleStateCreateInfo multisampling{};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
    
    // Depth stencil
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = desc.depthStencil.depthTestEnable ? VK_TRUE : VK_FALSE;
    depthStencil.depthWriteEnable = desc.depthStencil.depthWriteEnable ? VK_TRUE : VK_FALSE;
    depthStencil.depthCompareOp = ToVulkanCompareOp(desc.depthStencil.depthCompareOp);
    depthStencil.stencilTestEnable = desc.depthStencil.stencilTestEnable ? VK_TRUE : VK_FALSE;
    
    // Color blending
    VkPipelineColorBlendAttachmentState colorBlendAttachment{};
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.blendEnable = VK_FALSE;
    
    VkPipelineColorBlendStateCreateInfo colorBlending{};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;
    
    // Dynamic state
    VkDynamicState dynamicStates[] = {
        VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_SCISSOR
    };
    
    VkPipelineDynamicStateCreateInfo dynamicState{};
    dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicState.dynamicStateCount = 2;
    dynamicState.pDynamicStates = dynamicStates;
    
    // Pipeline layout
    VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 0;
    pipelineLayoutInfo.pushConstantRangeCount = 0;
    
    VK_CHECK(vkCreatePipelineLayout(m_Context.device, &pipelineLayoutInfo, nullptr, &m_Layout));
    
    // Create graphics pipeline
    VkGraphicsPipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pDepthStencilState = &depthStencil;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.pDynamicState = &dynamicState;
    pipelineInfo.layout = m_Layout;
    pipelineInfo.renderPass = renderPass;
    pipelineInfo.subpass = 0;
    
    VK_CHECK(vkCreateGraphicsPipelines(m_Context.device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &m_Pipeline));
    
    PBR_DEBUG << "Vulkan graphics pipeline created";
}

VulkanPipeline::~VulkanPipeline() {
    if (m_Pipeline != VK_NULL_HANDLE) {
        vkDestroyPipeline(m_Context.device, m_Pipeline, nullptr);
    }
    
    if (m_Layout != VK_NULL_HANDLE) {
        vkDestroyPipelineLayout(m_Context.device, m_Layout, nullptr);
    }
}

} // namespace rhi
} // namespace pbr

// ============================================================================
// src/rhi/vulkan/VulkanCommandBuffer.cpp
// ============================================================================
#include "pbr/core/Logger.h"
#include "pbr/rhi/vulkan/VulkanCommandBuffer.h"
#include "pbr/rhi/vulkan/VulkanTexture.h"
#include "pbr/rhi/vulkan/VulkanBuffer.h"
#include "pbr/rhi/vulkan/VulkanPipeline.h"

namespace pbr {
namespace rhi {

VulkanCommandBuffer::VulkanCommandBuffer(VulkanContext& context, VkCommandPool commandPool)
    : m_Context(context), m_CommandPool(commandPool) {
    
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = 1;
    
    VK_CHECK(vkAllocateCommandBuffers(m_Context.device, &allocInfo, &m_CommandBuffer));
}

VulkanCommandBuffer::~VulkanCommandBuffer() {
    if (m_CurrentFramebuffer != VK_NULL_HANDLE) {
        vkDestroyFramebuffer(m_Context.device, m_CurrentFramebuffer, nullptr);
    }
    
    if (m_CurrentRenderPass != VK_NULL_HANDLE) {
        vkDestroyRenderPass(m_Context.device, m_CurrentRenderPass, nullptr);
    }
    
    if (m_CommandBuffer != VK_NULL_HANDLE) {
        vkFreeCommandBuffers(m_Context.device, m_CommandPool, 1, &m_CommandBuffer);
    }
}

void VulkanCommandBuffer::Begin() {
    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    
    VK_CHECK(vkBeginCommandBuffer(m_CommandBuffer, &beginInfo));
    m_IsRecording = true;
}

void VulkanCommandBuffer::End() {
    VK_CHECK(vkEndCommandBuffer(m_CommandBuffer));
    m_IsRecording = false;
}

void VulkanCommandBuffer::BeginRendering(const std::vector<Ref<Texture>>& colorAttachments,
                                         Ref<Texture> depthAttachment,
                                         const std::vector<ClearValue>& clearValues) {
    
    // For this simple implementation, create a basic render pass
    VkAttachmentDescription colorAttachment{};
    auto vkTexture = std::static_pointer_cast<VulkanTexture>(colorAttachments[0]);
    colorAttachment.format = ToVulkanFormat(vkTexture->GetFormat());
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    
    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    
    VkSubpassDescription subpass{};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    
    VkRenderPassCreateInfo renderPassInfo{};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.attachmentCount = 1;
    renderPassInfo.pAttachments = &colorAttachment;
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    
    VK_CHECK(vkCreateRenderPass(m_Context.device, &renderPassInfo, nullptr, &m_CurrentRenderPass));
    
    // Create framebuffer
    VkImageView attachments[] = { vkTexture->GetImageView() };
    
    VkFramebufferCreateInfo framebufferInfo{};
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.renderPass = m_CurrentRenderPass;
    framebufferInfo.attachmentCount = 1;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.width = vkTexture->GetWidth();
    framebufferInfo.height = vkTexture->GetHeight();
    framebufferInfo.layers = 1;
    
    VK_CHECK(vkCreateFramebuffer(m_Context.device, &framebufferInfo, nullptr, &m_CurrentFramebuffer));
    
    // Begin render pass
    VkRenderPassBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    beginInfo.renderPass = m_CurrentRenderPass;
    beginInfo.framebuffer = m_CurrentFramebuffer;
    beginInfo.renderArea.offset = { 0, 0 };
    beginInfo.renderArea.extent = { vkTexture->GetWidth(), vkTexture->GetHeight() };
    
    VkClearValue vkClearValue{};
    if (!clearValues.empty()) {
        vkClearValue.color = { clearValues[0].color[0], clearValues[0].color[1],
                              clearValues[0].color[2], clearValues[0].color[3] };
    }
    
    beginInfo.clearValueCount = 1;
    beginInfo.pClearValues = &vkClearValue;
    
    vkCmdBeginRenderPass(m_CommandBuffer, &beginInfo, VK_SUBPASS_CONTENTS_INLINE);
}

void VulkanCommandBuffer::EndRendering() {
    vkCmdEndRenderPass(m_CommandBuffer);
}

void VulkanCommandBuffer::BindPipeline(Ref<Pipeline> pipeline) {
    auto vkPipeline = std::static_pointer_cast<VulkanPipeline>(pipeline);
    vkCmdBindPipeline(m_CommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, vkPipeline->GetHandle());
}

void VulkanCommandBuffer::SetViewport(const Viewport& viewport) {
    VkViewport vp{};
    vp.x = viewport.x;
    vp.y = viewport.y;
    vp.width = viewport.width;
    vp.height = viewport.height;
    vp.minDepth = viewport.minDepth;
    vp.maxDepth = viewport.maxDepth;
    
    vkCmdSetViewport(m_CommandBuffer, 0, 1, &vp);
}

void VulkanCommandBuffer::SetScissor(const Rect2D& scissor) {
    VkRect2D sc{};
    sc.offset = { scissor.x, scissor.y };
    sc.extent = { scissor.width, scissor.height };
    
    vkCmdSetScissor(m_CommandBuffer, 0, 1, &sc);
}

void VulkanCommandBuffer::BindVertexBuffer(Ref<Buffer> buffer, uint64 offset) {
    auto vkBuffer = std::static_pointer_cast<VulkanBuffer>(buffer);
    VkBuffer buffers[] = { vkBuffer->GetHandle() };
    VkDeviceSize offsets[] = { offset };
    
    vkCmdBindVertexBuffers(m_CommandBuffer, 0, 1, buffers, offsets);
}

void VulkanCommandBuffer::BindIndexBuffer(Ref<Buffer> buffer, uint64 offset) {
    auto vkBuffer = std::static_pointer_cast<VulkanBuffer>(buffer);
    vkCmdBindIndexBuffer(m_CommandBuffer, vkBuffer->GetHandle(), offset, VK_INDEX_TYPE_UINT32);
}

void VulkanCommandBuffer::Draw(uint32 vertexCount, uint32 instanceCount,
                              uint32 firstVertex, uint32 firstInstance) {
    vkCmdDraw(m_CommandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}

void VulkanCommandBuffer::DrawIndexed(uint32 indexCount, uint32 instanceCount,
                                     uint32 firstIndex, int32 vertexOffset,
                                     uint32 firstInstance) {
    vkCmdDrawIndexed(m_CommandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}

void VulkanCommandBuffer::CopyBuffer(Ref<Buffer> src, Ref<Buffer> dst,
                                    uint64 size, uint64 srcOffset, uint64 dstOffset) {
    auto vkSrc = std::static_pointer_cast<VulkanBuffer>(src);
    auto vkDst = std::static_pointer_cast<VulkanBuffer>(dst);
    
    VkBufferCopy copyRegion{};
    copyRegion.srcOffset = srcOffset;
    copyRegion.dstOffset = dstOffset;
    copyRegion.size = size;
    
    vkCmdCopyBuffer(m_CommandBuffer, vkSrc->GetHandle(), vkDst->GetHandle(), 1, &copyRegion);
}

} // namespace rhi
} // namespace pbr